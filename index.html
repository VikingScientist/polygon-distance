<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="primitives.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec3 vColor;

    void main(void) {
        gl_FragColor = vec4(vColor.x, vColor.y, vColor.z, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aColor;
    attribute vec3 aNormal;
    varying vec3 vColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uLightingDirection;
    uniform vec3 uDiffuseColor;
    uniform float uDiffuseAmount;

    uniform vec3 uAmbientColor;
    uniform float uAmbientAmount;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vec3 n = uNMatrix * aNormal;
		normalize(uLightingDirection);
		vec3 diffuse = max(dot(n,uLightingDirection), 0.0) * uDiffuseColor;
		vec3 ambient = uAmbientAmount * uAmbientColor;
		vColor = .5*aNormal+.5;
		// vColor = diffuse + uAmbientColor*uAmbientAmount;
		// vColor = (diffuse + ambient) * aColor;
		// vColor = .5*aVertexPosition + .5;
		// vColor = aColor;
		// vColor = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>


<script type="text/javascript">

	function Polygon(pts) {
		this.pts = pts;
		var u = [pts[6]-pts[3], pts[7]-pts[4], pts[8]-pts[5]];
		var v = [pts[3]-pts[0], pts[4]-pts[1], pts[5]-pts[2]];
		// evaluate normal vector and normalize it
		this.nor = [u[1]*v[2] - u[2]*v[1],
		            u[2]*v[0] - u[0]*v[2],
		            u[0]*v[1] - u[1]*v[0]];
		var len = Math.sqrt(this.nor[0]*this.nor[0] + this.nor[1]*this.nor[1] + this.nor[2]*this.nor[2]);
		this.nor[0] /= len;
		this.nor[1] /= len;
		this.nor[2] /= len;

		var centroid = [0,0,0];
		var k=0;
		for(var i=0; i<pts.length/3; i++) {
			centroid[0] += pts[k++];
			centroid[1] += pts[k++];
			centroid[2] += pts[k++];
		}
		centroid[0] /= pts.length/3;
		centroid[1] /= pts.length/3;
		centroid[2] /= pts.length/3;

		var c = new Vertex(centroid[0], centroid[1], centroid[2]);
		var n = new Vertex(this.nor[0], this.nor[1], this.nor[2]);
		var d = c.dot(n);
		if(d<0) {
			// alert("normal pointing the wrong way!");
			// document.write("<br>normal pointing the wrong way!<br>");
		}
		// document.write("<br>" + this.nor[0] + ", " + this.nor[1] + ", " + this.nor[2]);
		/*
		for (var i in this.pts) {
			document.write( this.pts[i] + ", ");
			if(i%3 == 2)
				document.write("<br>");
		}
		document.write("<br>");
		document.write("<br>");
		*/
	}

    var gl;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader   = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, "aColor");
        gl.enableVertexAttribArray(shaderProgram.colorAttribute);

        shaderProgram.normalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
        gl.enableVertexAttribArray(shaderProgram.normalAttribute);

        shaderProgram.pMatrixUniform  = gl.getUniformLocation(shaderProgram,  "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform  = gl.getUniformLocation(shaderProgram,  "uNMatrix");

        shaderProgram.lightDirectionUniform = gl.getUniformLocation(shaderProgram,  "uLightingDirection");
        shaderProgram.diffuseAmountUniform  = gl.getUniformLocation(shaderProgram,  "uDiffuseAmount");
        shaderProgram.ambientAmountUniform  = gl.getUniformLocation(shaderProgram,  "uAmbientAmount");
        shaderProgram.diffuseColorUniform   = gl.getUniformLocation(shaderProgram,  "uDiffuseColor");
        shaderProgram.ambientColorUniform   = gl.getUniformLocation(shaderProgram,  "uAmbientColor");
    }


    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();
    var normalMatrix = mat3.create();

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		mat4.toInverseMat3(mvMatrix, normalMatrix);
		mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }



    var vertexPositionBuffer;
    var colorBuffer;
    var normalBuffer;
    var indexBuffer;

    function initBuffers() {
		var vertices = [];
		var color    = [];
		var normal   = [];
		var indices  = [];
		var globI    = 0;
		// document.write("<br>Starting");
		for(var i in polygons) {
			var sides = polygons[i].pts.length/3;
			// document.write("<br>Polygon #" + i);
			var col = [Math.random(), Math.random(), Math.random()];
			for(var j=0; j<sides; j++) {
				vertices.push(polygons[i].pts[3*j]);
				vertices.push(polygons[i].pts[3*j+1]);
				vertices.push(polygons[i].pts[3*j+2]);
				// color.push(col[0]); color.push(col[1]); color.push(col[2]);
				color.push(.8);
				color.push(.1);
				color.push(.3);
				normal.push(polygons[i].nor[0]);
				normal.push(polygons[i].nor[1]);
				normal.push(polygons[i].nor[2]);
				// document.write("<br>  side #" + j);
			}
			for(var j=0; j<sides-2; j++) {
				indices.push(globI + 0);
				indices.push(globI + j+1);
				indices.push(globI + j+2);
			}
			globI += sides;
		}

        vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        vertexPositionBuffer.itemSize = 3;
        vertexPositionBuffer.numItems = vertices.length/3;

        colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.STATIC_DRAW);
        colorBuffer.itemSize = 3;
        colorBuffer.numItems = color.length/3;

        normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW);
        normalBuffer.itemSize = 3;
        normalBuffer.numItems = normal.length/3;

		indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        indexBuffer.itemSize = 1;
        indexBuffer.numItems = indices.length;

		// document.write("<br>ll done");
    }

	function initLigthing() {
		var ambientAmount = 0.2
		var ambientColor = vec3.create([1.0, 1.0, 1.0]);
		var diffuseAmount = 0.5
		var diffuseColor = vec3.create([1.0, 1.0, 1.0]);
		var lightDir     = vec3.create([-1.0, -1.0,  1.0]);
		// vec3.nomralize(lightDir);
        gl.uniform3fv(shaderProgram.lightDirectionUniform, lightDir);
        gl.uniform3fv(shaderProgram.ambientColorUniform, ambientColor);
        gl.uniform3fv(shaderProgram.diffuseColorUniform, diffuseColor);
        gl.uniform1f(shaderProgram.diffuseAmountUniform, diffuseAmount);
        gl.uniform1f(shaderProgram.ambientAmountUniform, ambientAmount);
	}

	var camR     = 5.0;
	var camPhi   = Math.PI / 3;
	var camTheta = 0.00;
    function drawScene() {
		// clear scene
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		// setup camera
        mat4.perspective(35, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, [0.0, 0.0, -camR]);
        mat4.rotate(mvMatrix, -camPhi, [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, camTheta, [0.0, 0.0, 1.0]);

		// set color
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(shaderProgram.colorAttribute, colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

		// set position
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

		// set normals
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.vertexAttribPointer(shaderProgram.normalAttribute, normalBuffer.itemSize, gl.FLOAT, false, 0, 0);

		// set indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		
		// make drawcall
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

	var lastTime = 0;
	function animate() {
		var nowTime = new Date().getTime();
		if (lastTime != 0) {
			var elapsed = nowTime - lastTime;

			// camPhi   += 2*Math.PI*elapsed / 32000.0;
			camTheta += 2*Math.PI*elapsed / 6000.0;
		}
		lastTime = nowTime;
	}

	var polygons = [];
	var vertices = [];
	var faces    = [];
	var geosidicFace = [];
	var edges    = [];
	function initDodecahedron() {
		var phi = (1+Math.sqrt(5.0))/2.0;
		var pts = [ 1.0, 1.0, 1.0, 
		            1.0,-1.0, 1.0, 
		            1.0, 1.0,-1.0, 
		            1.0,-1.0,-1.0, 
		           -1.0, 1.0, 1.0,  // pts[4]
		           -1.0,-1.0, 1.0, 
		           -1.0, 1.0,-1.0, 
		           -1.0,-1.0,-1.0, 
		              0, 1.0/phi, phi, // pts[8]
		              0,-1.0/phi, phi,
		              0, 1.0/phi,-phi,
		              0,-1.0/phi,-phi,
		            1.0/phi,  phi, 0, // pts[12]
		           -1.0/phi,  phi, 0,
		            1.0/phi, -phi, 0,
		           -1.0/phi, -phi, 0,
		            phi, 0,   1.0/phi, //pts[16]
		            phi, 0,  -1.0/phi,
		           -phi, 0,   1.0/phi,
		           -phi, 0,  -1.0/phi];
		var indx = [15, 14, 3, 11, 7,
		            14, 3, 17, 16, 1,
		        	17, 16, 0, 12, 2,
					3, 17, 2, 10, 11,
					7, 11, 10, 6, 19,
					10, 2, 12, 13, 6,
					1, 9, 8, 0, 16,
					9, 5, 18, 4, 8,
					8, 4, 13, 12, 0,
					5, 15, 7, 19, 18,
					4, 18, 19, 6, 13,
					15, 5, 9, 1, 14];
		for(var i=0; i<indx.length/5; i++) {
			var locPt = [];
			for(var j=0; j<5; j++) {
				var k = indx[i*5+j];
				locPt.push(pts[3*k  ]);
				locPt.push(pts[3*k+1]);
				locPt.push(pts[3*k+2]);
			}
			polygons.push(new Polygon(locPt));
		}
	}

	function initIcosahedron() {
		var phi = (1+Math.sqrt(5.0))/2.0;
		var pts = [ 0,   1,   phi, 
		            0,  -1,   phi, 
		            0,   1,  -phi, 
		            0,  -1,  -phi, 
		             1,   phi, 0,  
		            -1,   phi, 0,  
		             1,  -phi, 0,  
		            -1,  -phi, 0,  
		            phi, 0,   1, 
		           -phi, 0,   1,
		            phi, 0,  -1,
		           -phi, 0,  -1];
		var indx = [0,  8,  1,      0,  1,  9,      0,  4,  8,      0,  5,  4,  
                    0,  9,  5,      2, 11,  3,      2,  5, 11,      2,  4,  5,  
                    2, 10,  4,      2,  3, 10,      1,  7,  9,      1,  6,  7,  
                    1,  8,  6,      3,  6, 10,      3,  7,  6,      3, 11,  7,  
                    4, 10,  8,      5,  9, 11,      6,  8, 10,      7, 11,  9];

		for(var i=0; i<pts.length/3; i++)
			vertices.push(new Vertex(pts[3*i], pts[3*i+1], pts[3*i+2]));

		for(var i=0; i<indx.length/3; i++) {
			var locPt = [];
			var locVert = [];
			for(var j=0; j<3; j++) {
				var k = indx[i*3+j];
				locPt.push(pts[3*k  ]);
				locPt.push(pts[3*k+1]);
				locPt.push(pts[3*k+2]);
				locVert.push(vertices[k]);
			}
			polygons.push(new Polygon(locPt));
			var f = new Face(locVert);
			faces.push(f);
			var newE;
			for(var j=0; j<3; j++) {
				newE = new Edge(locVert[j], locVert[(j+1)%3]);
				newE.face.push(f);
				var found = false;
				for(var k in edges) {
					if(newE.equals(edges[k])) {
						newE = edges[k];
						newE.face.push(f);
						found = true;
						break;
					}
				}
				if(!found)
					edges.push(newE);
				f.edge.push(newE);
			}
		}

		/*  debugging output
		for(var i in faces) {
			document.write("<br>Face #"+i+":");
			for(var j in faces[i].edge) {
				var edgeI = -1;
				for(var k in edges)
					if(faces[i].edge[j].equals(edges[k]))
						edgeI = k;
				document.write("<br>&nbsp &nbsp edge #"+edgeI+":&nbsp");
				var ptI = -1;
				for(var k in vertices)
					if(faces[i].edge[j].vertex[0].equals(vertices[k]))
						ptI = k;
				document.write(ptI + ", ");
				for(var k in vertices)
					if(faces[i].edge[j].vertex[1].equals(vertices[k]))
						ptI = k;
				document.write("" + ptI);
				if(faces[i].edge[j].face[1].equals(faces[i]))
					document.write(" (-1)");
			}
		}
		*/
    }

	function makeGeosidic(n,m) {
		// make sure n is always the biggest number
		if(n < m) {
			tmp = m; m = n; n = tmp;
		}
		if(m == 0) { // paralell type subdivision
			for(var i in edges) {
				for(var t=1; t<n; t++) {
					var p1 = edges[i].vertex[0].mult(1.0*(n-t)/n);
					var p2 = edges[i].vertex[1].mult(1.0*( t )/n);
					var p  = p1.add(p2);
					// var p1 = edges[i].vertex[0];
					// var p2 = edges[i].vertex[1];
					// var p  = new Vertex((p1.x[0]*(1-t) + p2.x[0]*t)/n, 
					                    // (p1.x[1]*(1-t) + p2.x[1]*t)/n, 
					                    // (p1.x[2]*(1-t) + p2.x[2]*t)/n);
					// document.write("INSERTING INTERIOR POINT in i=" + i + " p = (" + p + ")<br>");
					edges[i].intVertices.push(p);
					vertices.push(p);
				}
				// for(var k in edges[i].intVertices)
					// document.write("&nbsp " + edges[i].intVertices[k] + "<br>");
			}
			for(var i in faces) {
				for(var t=1; t<n-1; t++) {
					for(var s=1; s<n-t; s++) {
						var z1 = 1.0*t/n;
						var z2 = 1.0*s/n;
						var z3 = 1.0 - z1 - z2;
						var p1 = faces[i].vertices[0].mult(z1);
						var p2 = faces[i].vertices[1].mult(z2);
						var p3 = faces[i].vertices[2].mult(z3);
						var pp = p1.add(p2);
						var p  = pp.add(p3); // p = z1*p1 + z2*p2 + z3*p3
						faces[i].intVertices.push(p);
						vertices.push(p);
					}
				}
				var e1 = faces[i].edge[0];
				var e2 = faces[i].edge[1];
				var e3 = faces[i].edge[2];
				var e1Reverse = e1.face[1].equals(faces[i]);
				var e2Reverse = e2.face[1].equals(faces[i]);
				var e3Reverse = e3.face[1].equals(faces[i]);

				var locSize = n+1;
				var locVertices = [faces[i].vertices[2]];
				for(var j=0; j<n-1; j++)
					locVertices.push(e2.intVertices[(e2Reverse)?j:(n-j-2)]);
				locVertices.push(faces[i].vertices[1])
				for(var j=0; j<n-1; j++) {
					locI = ((locSize+1)*locSize - (locSize-j)*(locSize-j-1))/2;
					locVertices[locI] = e3.intVertices[(e3Reverse)?(n-j-2):j];
				}
				locI = 2*locSize-2;
				for(var j=0; j<n-1; j++) {
					locVertices[locI] = e1.intVertices[(e1Reverse)?j:(n-j-2)];
					locI += locSize-j-2;
				}
				var locI = locSize+1;
				var st   = 0;
				for(var j=1; j<locSize-2; j++) {
					for(var k=1; k<locSize-1-j; k++) {
						locVertices[locI] = faces[i].intVertices[st++];
						locI++;
					}
					locI+=2;
				}
				locVertices.push(faces[i].vertices[0]);

				st = 0;
				for(var j=0; j<locSize-1; j++) {
					for(var k=0; k<locSize-1-j; k++) {
						geosidicFace.push(new Face([locVertices[ st ],
						                            locVertices[ st+(locSize-j)],
						                            locVertices[ st+1 ]]));
						st++;
					}
					st++;
				}
				st = locSize;
				for(var j=1; j<locSize; j++) {
					for(var k=0; k<locSize-1-j; k++) {
						geosidicFace.push(new Face([locVertices[ st ],
						                            locVertices[ st+1 ],
						                            locVertices[ st-locSize+j]]));
						st++;
					}
					st++;
				}
			}

			polygons = [];
			for(var i in geosidicFace)
				polygons.push(new Polygon(geosidicFace[i].getVertexList()));
		} else if(m == n) { // reflexible type
		} else { // chirall patterns
		}
	}

	function projectSphere() {
		for(var i in vertices) {
			vertices[i].normalize();
			// document.write("<br>vertex #" + i + " has lenght " + vertices[i].len());
		}
		polygons = [];
		for(var i in geosidicFace)
			polygons.push(new Polygon(geosidicFace[i].getVertexList()));
	}

	function makeDualMesh() {
		var finalVert = [];
		var finalFace = [];
		for(var i in geosidicFace) {
			for(var j in geosidicFace[i].vertices) {
				geosidicFace[i].vertices[j].addFace(i);
			}
			finalVert.push(geosidicFace[i].getCentroid());
		}
		for(var i in vertices) {
			var locVert = [];
			for(var j in vertices[i].face) {
				locVert.push(finalVert[vertices[i].face[j]]);
			}
			if(locVert.length>2)  {
				var newF = new Face(locVert);
				newF.reorganizePoints();
				finalFace.push(newF);
			}
		}
		polygons = [];
		for(var i in finalFace) {
			polygons.push(new Polygon(finalFace[i].getVertexList()));
		}
	}

	function tick() {
        requestAnimFrame(tick);
		drawScene();
		animate();
	}

    function webGLStart() {
        var canvas = document.getElementById("civ6");
        initGL(canvas);
        initShaders();
		initIcosahedron();
		makeGeosidic(5,0);
		projectSphere();
		makeDualMesh();
        initBuffers();
        initLigthing();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

		var v1 = new Vertex(.3,.4,.5);

		tick();
    }


</script>


</head>


<body onload="webGLStart();">
    <canvas id="civ6" style="border: none;" width="500" height="500"></canvas>
</body>

</html>
